"0","#	The Viterbi algorithm.  See page 30 of notes ""Lecture Notes for MATH2307, Part  I Bioinformatics"""
"0","#	The input parameters are those for Example 3.1 in the notes"
"0",""
"0","#	Markov transition matrix: "
"0","#		Pi must be square, "
"0","#		rows of Pi plus p_i0 must sum to 1"
"0","#		elements of p_0j must sum to 1"
"0","#	Warning: it looks like the transpose of what's needed in the following lines of code "
"0","#		because of the way R converts vectors to arrays"
"0","#"
"0","	Pi <- array(c(0.8,0.1,"
"0","                0.1,0.8), dim=c(2, 2))"
"0","	p_0j <- c(0.6,0.4)"
"0","	p_i0 <- c(0.1,0.1)"
"0","	states <- c(""FAIR"", ""LOADED"")	"
"0","#"
"0","#	emission probabilities: q[a, i] is the probability of emitting symbol a from state i"
"0","#"
"0","	q <- array(c(	1/6,1/6, 1/6,1/6,1/6,1/6,"
"0","                1/10,1/10,1/10,1/10,1/10,1/2), dim=c(6,2))"
"0","#"
"0","#	Observed sequence of symbols"
"0","#"
"0","	x <- c(1,6,2,5,6,1,6,2,5,2)	"
"0","#	x <- sample(1:2, size = 500, replace=TRUE)"
"0","#"
"0","	N <- dim(Pi)[1]			# Number of Markov states extracted from Pi"
"0","	alphaSize <- dim(q)[1]	# alphabet size"
"0","	L <- length(x)			# length of path"
"0","#"
"0","#	Consistency checks on input parameters"
"0","#"
"0","	if(dim(Pi)[2] != N)	stop(""Pi is not square"")"
"0","	if(length(p_0j) != N) stop(""p_0j is the wrong length"")"
"0","	if(length(p_i0) != N) stop(""p_i0 is the wrong length"")"
"0","	if(!isTRUE(all.equal(rowSums(Pi) + p_i0, rep(1,N))))"
"0","							stop(""rows of (Pi, p_i0) don't sum to 1"")"
"0","	if(sum(p_0j) != 1)	stop(""elements of p_0j don't sum to 1"")"
"0","	if(length(states)!=N) stop(""wrong number of state labels"")"
"0","	if(dim(q)[2]!=N)		stop(""size of array q doesn't match number of Markov states"")"
"0","	if(!isTRUE(all.equal(colSums(q), rep(1,N))))"
"0","						stop(""q probabilities don't sum to 1"")"
"0","#"
"0","#	Set up arrays for v and pointers:"
"0","#		v[l,i] is probability of Viterbi path ending in state l with timestep i"
"0","#		ptr[i, l] points back to optimum state at timestep i-1 from timestep i"
"0","#		piStar is the optimum Markovian path "
"0","#"
"0","	v <- array(dim=c(N, L))"
"0","	ptr <- array(dim=c(L, N))"
"0","	piStar <- array(dim=L)"
"0","#"
"0","#	Initialisation"
"0","#"
"0","	v[,1] <- p_0j*q[x[1],]"
"0","	ptr[1,] <- rep(0,N)"
"0","#"
"0","#	Recursion"
"0","#"
"0","	for(t in 1:(L - 1)){"
"0","		for(l in 1:N){"
"0","			v[l,t + 1] <- max(v[,t]*Pi[,l])*q[x[t + 1],l]"
"0","			ptr[t + 1,l] <- which.max(v[, t]*Pi[,l])"
"0","			}"
"0","		}"
"0","#"
"0","#	Termination"
"0","#"
"0","	Prob <- max(v[,L]*p_i0)"
"0","	piStar[L] <- which.max(v[,L]*p_i0)"
"0","#"
"0","#	Traceback"
"0","#"
"0","	for(t in L:2){"
"0","		piStar[t - 1] <- ptr[t, piStar[t]]"
"0","		}"
"0","#"
"0","	cat(""\n Observed Sequence:\n"")"
"1","
 Observed Sequence:
"
"0","	cat(""   x ="", x, ""\n\n"")"
"1","   x ="
"1"," "
"1","1"
"1"," "
"1","6"
"1"," "
"1","2"
"1"," "
"1","5"
"1"," "
"1","6"
"1"," "
"1","1"
"1"," "
"1","6"
"1"," "
"1","2"
"1"," "
"1","5"
"1"," "
"1","2"
"1"," "
"1","

"
"0","#"
"0","	cat(""\n Probability of the most probable path ="", Prob, "
"0","		 ""\n\n Most probable path:  \n"")"
"1","
 Probability of the most probable path ="
"1"," "
"1","1.331829e-10"
"1"," "
"1","

 Most probable path:  
"
"0","	cat(c(""   pi = B"", states[piStar], ""E""), ""\n\n"")"
"1","   pi = B"
"1"," "
"1","FAIR"
"1"," "
"1","FAIR"
"1"," "
"1","FAIR"
"1"," "
"1","FAIR"
"1"," "
"1","FAIR"
"1"," "
"1","FAIR"
"1"," "
"1","FAIR"
"1"," "
"1","FAIR"
"1"," "
"1","FAIR"
"1"," "
"1","FAIR"
"1"," "
"1","E"
"1"," "
"1","

"
"0","#"
"0",""
